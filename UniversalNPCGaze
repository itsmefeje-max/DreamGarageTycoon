-- Purpose: Handles cinematic head tracking for all NPCs, and full-body tracking for specific configured NPCs.
-- Runs on: Client
-- Location: StarterPlayerScripts
-- Dependencies: Workspace.NPCS
-- Public API: N/A
-- Networking: N/A (Purely visual client-side effect)
-- Security: Safe (Local visual manipulation only; does not replicate to server)
-- Performance: Uses an O(1) dictionary lookup for full-body tracking to keep RenderStepped fast.
-- Notes: Assumes the full-body tracked NPCs are Anchored R15 rigs.

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local npcFolder = Workspace:WaitForChild("NPCS")

-- âš™ï¸ SUPER SLOW TUNING
local MAX_DISTANCE = 35        -- Studs: Range to start looking
local RETURN_SPEED = 0.005     -- Extremely slow drift back (Heavy feel)
local TRACK_SPEED = 0.02       -- Gentle turn when looking at you
local BODY_TRACK_SPEED = 0.015 -- Natural "head turns first, body follows" effect
local SHOULDER_LIMIT = 85      -- Degrees: Angle where they stop looking
local VERTICAL_LIMIT = 40      -- Degrees: Max Up/Down angle

-- ðŸ“‹ CONFIGURATION: Add NPC names here for full-body tracking
-- We use a dictionary [Name] = true for instant O(1) lookup in the Render loop.
local FULL_BODY_TRACKING_NPCS = {
	["Monk3yDAngelo"] = true,
	["AnotherNPC_NameHere"] = false, -- Example of how to add more
}

-- ðŸ› ï¸ MATH HELPER: Normalize angles
local function getGoalCFrame(rootPart, lookAtPos)
	local relativePos = rootPart.CFrame:PointToObjectSpace(lookAtPos)

	-- 1. BEHIND CHECK
	if relativePos.Z > 0.5 then
		return CFrame.new() 
	end

	-- 2. CALCULATE ANGLES
	local xAngle = math.atan2(relativePos.Y, -relativePos.Z)
	local yAngle = math.atan2(-relativePos.X, -relativePos.Z)

	-- 3. SHOULDER CHECK
	if math.abs(math.deg(yAngle)) > SHOULDER_LIMIT then
		return CFrame.new() 
	end

	-- 4. CLAMP VERTICAL
	xAngle = math.clamp(xAngle, math.rad(-VERTICAL_LIMIT), math.rad(VERTICAL_LIMIT))

	-- 5. RETURN GOAL 
	return CFrame.Angles(xAngle / 1.5, yAngle, 0)
end

-- ðŸ”„ MAIN RENDER LOOP
RunService.RenderStepped:Connect(function()
	local myCharacter = player.Character
	if not myCharacter then return end

	local myHead = myCharacter:FindFirstChild("Head")
	if not myHead then return end

	for _, npc in pairs(npcFolder:GetChildren()) do
		if npc:IsA("Model") then
			local head = npc:FindFirstChild("Head")
			local torso = npc:FindFirstChild("UpperTorso")
			local rootPart = npc:FindFirstChild("HumanoidRootPart")

			-- [1] HEAD TRACKING (All Valid NPCs)
			if head and torso then
				local neck = head:FindFirstChild("Neck")
				if neck then
					if not neck:GetAttribute("OriginalC0") then
						neck:SetAttribute("OriginalC0", neck.C0)
					end
					local originalC0 = neck:GetAttribute("OriginalC0")

					local dist = (head.Position - myHead.Position).Magnitude
					local targetCFrame = CFrame.new()
					local currentAlpha = RETURN_SPEED 

					if dist < MAX_DISTANCE then
						local potentialGoal = getGoalCFrame(torso, myHead.Position)

						if potentialGoal == CFrame.new() then
							targetCFrame = CFrame.new()
							currentAlpha = RETURN_SPEED 
						else
							targetCFrame = potentialGoal
							currentAlpha = TRACK_SPEED
						end
					else
						targetCFrame = CFrame.new()
						currentAlpha = RETURN_SPEED
					end

					neck.C0 = neck.C0:Lerp(originalC0 * targetCFrame, currentAlpha)
				end
			end

			-- [2] FULL BODY TRACKING (Configured NPCs Only)
			-- Uses the O(1) dictionary lookup for maximum performance
			if rootPart and FULL_BODY_TRACKING_NPCS[npc.Name] then
				local dist = (rootPart.Position - myHead.Position).Magnitude

				if dist < MAX_DISTANCE then
					-- Project player position onto the NPC's Y plane to prevent tilting the entire body up/down
					local lookTarget = Vector3.new(myHead.Position.X, rootPart.Position.Y, myHead.Position.Z)

					-- Prevent CFrame.lookAt math error if positions are exactly identical
					if (rootPart.Position - lookTarget).Magnitude > 0.05 then
						local goalBodyCFrame = CFrame.lookAt(rootPart.Position, lookTarget)

						-- Smoothly rotate the body
						rootPart.CFrame = rootPart.CFrame:Lerp(goalBodyCFrame, BODY_TRACK_SPEED)
					end
				end
			end

		end
	end
end)
