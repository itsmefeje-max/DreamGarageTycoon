-- FINAL: Functional Loading Screen
-- Camera Part Ready + Real Preload + Fade + Blur + No Movement + Hide ALL other UI contents (no ScreenGui.Enabled toggles)
-- Runs on: Client (ReplicatedFirst)

local ReplicatedFirst = game:GetService("ReplicatedFirst")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local StarterGui = game:GetService("StarterGui")
local TweenService = game:GetService("TweenService")
local ContentProvider = game:GetService("ContentProvider")
local ContextActionService = game:GetService("ContextActionService")
local Lighting = game:GetService("Lighting")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

ReplicatedFirst:RemoveDefaultLoadingScreen()

-- =====================
-- CONFIG
-- =====================
local VIEW_PART_NAME = "LoadingViewPart"
local VIEW_PART_TIMEOUT = 20

local LOCK_NAME = "LoadingScreenCameraLock"
local FREEZE_ACTION = "LoadingScreenFreeze"

local FADE_IN_TIME = 0.75
local FADE_OUT_TIME = 0.85

local BLUR_SIZE = 20
local BLUR_IN_TIME = 0.5
local BLUR_OUT_TIME = 0.5

local EXTRA_HOLD_SECONDS = 3.0

-- Progress ranges per phase
local PHASE_GAME_LOADED_TO = 0.15
local PHASE_VIEWPART_READY_TO = 0.30
local PHASE_PRELOAD_TO = 0.95
local PHASE_FINISH_TO = 1.00

-- Optional: put Instances you want preloaded inside ReplicatedStorage.PreloadAssets (Folder)
local PRELOAD_FOLDER_NAME = "PreloadAssets"

-- If you want some UI to still show during loading, whitelist its ScreenGui name here.
-- (We’ll still hide everything else.)
local SCREEN_GUI_WHITELIST = {
	ActiveLoadingScreen = true,
}

-- =====================
-- BASICS
-- =====================
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local camera = Workspace.CurrentCamera or Workspace:WaitForChild("Camera")

-- =====================
-- UTIL
-- =====================
local function waitForNamedChild(parent, childName, timeout)
	local start = os.clock()
	while os.clock() - start < timeout do
		local child = parent:FindFirstChild(childName)
		if child then return child end
		RunService.Heartbeat:Wait()
	end
	return nil
end

local function safeTween(instance, info, goals)
	local t = TweenService:Create(instance, info, goals)
	t:Play()
	return t
end

-- =====================
-- BLUR
-- =====================
local blur = Lighting:FindFirstChild("LoadingScreenBlur")
if not blur then
	blur = Instance.new("BlurEffect")
	blur.Name = "LoadingScreenBlur"
	blur.Size = 0
	blur.Parent = Lighting
end

local function blurTo(size, duration)
	return safeTween(blur, TweenInfo.new(duration, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), { Size = size })
end

-- =====================
-- LOCK INPUT CONTROLS
-- =====================
local function lockControls()
	ContextActionService:BindAction(
		FREEZE_ACTION,
		function() return Enum.ContextActionResult.Sink end,
		false,
		unpack(Enum.PlayerActions:GetEnumItems())
	)
end

local function unlockControls()
	pcall(function() ContextActionService:UnbindAction(FREEZE_ACTION) end)
end

-- =====================
-- FORCE NO MOVEMENT (Humanoid Lock)
-- =====================
local movementLock = {
	active = false,
	charConn = nil,
	original = {}, -- [humanoid] = {WalkSpeed, JumpPower, JumpHeight, AutoRotate}
}

local function applyMovementLockToCharacter(char)
	if not movementLock.active or not char then return end

	local hum = char:FindFirstChildOfClass("Humanoid") or char:WaitForChild("Humanoid", 5)
	if not hum then return end

	if not movementLock.original[hum] then
		movementLock.original[hum] = {
			WalkSpeed = hum.WalkSpeed,
			JumpPower = hum.JumpPower,
			JumpHeight = hum.JumpHeight,
			AutoRotate = hum.AutoRotate,
		}
	end

	hum.WalkSpeed = 0
	hum.JumpPower = 0
	hum.JumpHeight = 0
	hum.AutoRotate = false

	local root = char:FindFirstChild("HumanoidRootPart")
	if root then
		root.AssemblyLinearVelocity = Vector3.zero
		root.AssemblyAngularVelocity = Vector3.zero
	end

	pcall(function()
		hum:Move(Vector3.zero, true)
	end)
end

local function enableMovementLock()
	movementLock.active = true
	if player.Character then
		applyMovementLockToCharacter(player.Character)
	end
	movementLock.charConn = player.CharacterAdded:Connect(function(newChar)
		applyMovementLockToCharacter(newChar)
	end)
end

local function disableMovementLock()
	movementLock.active = false
	if movementLock.charConn then
		movementLock.charConn:Disconnect()
		movementLock.charConn = nil
	end

	for hum, original in pairs(movementLock.original) do
		if hum and hum.Parent then
			hum.WalkSpeed = original.WalkSpeed or 16
			hum.JumpPower = original.JumpPower or 50
			hum.JumpHeight = original.JumpHeight or 7.2
			hum.AutoRotate = (original.AutoRotate ~= nil) and original.AutoRotate or true
		end
	end
	table.clear(movementLock.original)
end

-- =====================
-- CAMERA LOCK TO VIEW PART
-- =====================
local function lockCameraTo(part)
	if not part or not part:IsA("BasePart") then return end

	camera.CameraType = Enum.CameraType.Scriptable
	camera.CFrame = part.CFrame

	RunService:BindToRenderStep(LOCK_NAME, Enum.RenderPriority.Camera.Value + 1, function()
		if part and part.Parent then
			camera.CFrame = part.CFrame
		end
		if camera.CameraType ~= Enum.CameraType.Scriptable then
			camera.CameraType = Enum.CameraType.Scriptable
		end
	end)
end

local function unlockCameraToPlayer()
	pcall(function() RunService:UnbindFromRenderStep(LOCK_NAME) end)

	local char = player.Character or player.CharacterAdded:Wait()
	local hum = char:FindFirstChildOfClass("Humanoid") or char:WaitForChild("Humanoid", 10)

	camera.CameraType = Enum.CameraType.Custom
	if hum then
		camera.CameraSubject = hum
	end
end

-- =====================
-- HIDE ALL OTHER UI CONTENTS (Future-proof, avoids ScreenGui.Enabled toggles)
-- =====================
local uiHide = {
	active = false,
	connAdded = nil,
	-- originalState[GuiObject] = {Visible=bool, Active=bool}
	originalState = {},
	hiddenObjects = {}, -- array of GuiObjects we manage
	enforceThread = nil,
}

local function shouldManageScreenGui(screenGui, loadingGui)
	if screenGui == loadingGui then return false end
	if SCREEN_GUI_WHITELIST[screenGui.Name] then return false end
	return true
end

local function captureAndHideGuiObject(obj)
	if not obj:IsA("GuiObject") then return end

	-- Store original once
	if uiHide.originalState[obj] == nil then
		uiHide.originalState[obj] = {
			Visible = obj.Visible,
			Active = obj.Active,
		}
		table.insert(uiHide.hiddenObjects, obj)
	end

	-- Hide + disable input
	obj.Visible = false
	obj.Active = false
end

local function hideAllOtherUiContents(loadingGui)
	for _, child in ipairs(playerGui:GetChildren()) do
		if child:IsA("ScreenGui") and shouldManageScreenGui(child, loadingGui) then
			for _, d in ipairs(child:GetDescendants()) do
				captureAndHideGuiObject(d)
			end
		end
	end
end

local function beginHideOtherUiContents(loadingGui)
	uiHide.active = true
	hideAllOtherUiContents(loadingGui)

	-- Hide any UI added during loading (future-proof)
	uiHide.connAdded = playerGui.DescendantAdded:Connect(function(desc)
		if not uiHide.active then return end

		-- Only manage descendants that belong to non-whitelisted ScreenGuis
		local sg = desc:FindFirstAncestorOfClass("ScreenGui")
		if sg and shouldManageScreenGui(sg, loadingGui) then
			captureAndHideGuiObject(desc)
		end
	end)

	-- Enforce in case some other script tries to make things visible during loading
	uiHide.enforceThread = task.spawn(function()
		while uiHide.active do
			for i = #uiHide.hiddenObjects, 1, -1 do
				local obj = uiHide.hiddenObjects[i]
				if not obj or not obj.Parent then
					uiHide.hiddenObjects[i] = uiHide.hiddenObjects[#uiHide.hiddenObjects]
					uiHide.hiddenObjects[#uiHide.hiddenObjects] = nil
				else
					-- Keep it hidden during loading no matter what
					if obj.Visible ~= false then obj.Visible = false end
					if obj.Active ~= false then obj.Active = false end
				end
			end
			task.wait(0.15)
		end
	end)
end

local function restoreOtherUiContents()
	uiHide.active = false

	if uiHide.connAdded then
		uiHide.connAdded:Disconnect()
		uiHide.connAdded = nil
	end

	-- Restore original Visible/Active for everything we touched
	for obj, state in pairs(uiHide.originalState) do
		if obj and obj.Parent then
			obj.Visible = state.Visible
			obj.Active = state.Active
		end
	end

	table.clear(uiHide.originalState)
	table.clear(uiHide.hiddenObjects)
end

-- =====================
-- UI SETUP
-- =====================
local sourceGui = StarterGui:WaitForChild("LoadingScreenGui", 10)
if not sourceGui then
	warn("❌ CRITICAL: LoadingScreenGui missing in StarterGui!")
	return
end

local loadingGui = sourceGui:Clone()
loadingGui.Name = "ActiveLoadingScreen"
loadingGui.ResetOnSpawn = false
loadingGui.Enabled = true
loadingGui.Parent = playerGui
SCREEN_GUI_WHITELIST[loadingGui.Name] = true

-- Hide other UI contents immediately (prevents auto-open side effects from Enabled toggles)
beginHideOtherUiContents(loadingGui)

local bgFrame = loadingGui:WaitForChild("Frame", 5)
if not bgFrame then
	warn("❌ CRITICAL: Frame missing inside LoadingScreenGui!")
	restoreOtherUiContents()
	loadingGui:Destroy()
	return
end
bgFrame.Visible = true

local barContainer = bgFrame:WaitForChild("ProgressBarContainer", 5)
local barFill = barContainer and barContainer:WaitForChild("ProgressBar", 5)
local progressText = barContainer and barContainer:FindFirstChild("ProgressText")

if not barFill then
	warn("❌ CRITICAL: ProgressBar missing.")
	restoreOtherUiContents()
	loadingGui:Destroy()
	return
end

local MAX_X_SCALE = barFill.Size.X.Scale
local MAX_X_OFFSET = barFill.Size.X.Offset
local Y_SCALE = barFill.Size.Y.Scale
local Y_OFFSET = barFill.Size.Y.Offset
barFill.Size = UDim2.new(0, 0, Y_SCALE, Y_OFFSET)

local progressValue = Instance.new("NumberValue")
progressValue.Value = 0
progressValue.Changed:Connect(function(v)
	barFill.Size = UDim2.new(MAX_X_SCALE * v, MAX_X_OFFSET * v, Y_SCALE, Y_OFFSET)
	if progressText then
		progressText.Text = string.format("%d%%", math.floor(v * 100 + 0.5))
	end
end)

local function tweenProgress(toValue, duration, easingStyle, easingDir)
	return safeTween(
		progressValue,
		TweenInfo.new(duration, easingStyle or Enum.EasingStyle.Sine, easingDir or Enum.EasingDirection.Out),
		{ Value = toValue }
	)
end

-- =====================
-- FADE SYSTEM (Studio transparencies)
-- =====================
local studio = {} -- [Instance] = {props...}

local function recordStudioProps(inst)
	local props = {}
	local changed = false

	if inst:IsA("GuiObject") and inst.BackgroundTransparency < 1 then
		props.BackgroundTransparency = inst.BackgroundTransparency
		changed = true
	end
	if (inst:IsA("TextLabel") or inst:IsA("TextButton") or inst:IsA("TextBox")) and inst.TextTransparency < 1 then
		props.TextTransparency = inst.TextTransparency
		changed = true
	end
	if (inst:IsA("ImageLabel") or inst:IsA("ImageButton")) and inst.ImageTransparency < 1 then
		props.ImageTransparency = inst.ImageTransparency
		changed = true
	end
	if inst:IsA("UIStroke") and inst.Transparency < 1 then
		props.Transparency = inst.Transparency
		changed = true
	end

	if changed then
		studio[inst] = props
	end
end

local function setInvisible(inst)
	local props = studio[inst]
	if not props then return end

	if inst:IsA("GuiObject") and props.BackgroundTransparency ~= nil then
		inst.BackgroundTransparency = 1
	end
	if (inst:IsA("TextLabel") or inst:IsA("TextButton") or inst:IsA("TextBox")) and props.TextTransparency ~= nil then
		inst.TextTransparency = 1
	end
	if (inst:IsA("ImageLabel") or inst:IsA("ImageButton")) and props.ImageTransparency ~= nil then
		inst.ImageTransparency = 1
	end
	if inst:IsA("UIStroke") and props.Transparency ~= nil then
		inst.Transparency = 1
	end
end

local function fadeToStudio(duration)
	local info = TweenInfo.new(duration, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
	for inst, goals in pairs(studio) do
		if inst and inst.Parent then
			safeTween(inst, info, goals)
		end
	end
end

local function fadeToInvisible(duration)
	local info = TweenInfo.new(duration, Enum.EasingStyle.Sine, Enum.EasingDirection.In)
	for inst, _ in pairs(studio) do
		if inst and inst.Parent then
			local goals = {}
			local props = studio[inst]

			if inst:IsA("GuiObject") and props.BackgroundTransparency ~= nil then goals.BackgroundTransparency = 1 end
			if (inst:IsA("TextLabel") or inst:IsA("TextButton") or inst:IsA("TextBox")) and props.TextTransparency ~= nil then goals.TextTransparency = 1 end
			if (inst:IsA("ImageLabel") or inst:IsA("ImageButton")) and props.ImageTransparency ~= nil then goals.ImageTransparency = 1 end
			if inst:IsA("UIStroke") and props.Transparency ~= nil then goals.Transparency = 1 end

			if next(goals) then
				safeTween(inst, info, goals)
			end
		end
	end
end

for _, inst in ipairs(loadingGui:GetDescendants()) do
	recordStudioProps(inst)
end
for inst, _ in pairs(studio) do
	setInvisible(inst)
end

-- =====================
-- PRELOAD LIST BUILDER
-- =====================
local function buildPreloadList(viewPart)
	local list = { loadingGui }

	local folder = ReplicatedStorage:FindFirstChild(PRELOAD_FOLDER_NAME)
	if folder then
		for _, inst in ipairs(folder:GetDescendants()) do
			table.insert(list, inst)
		end
	end

	if viewPart then
		table.insert(list, viewPart)
		if viewPart.Parent then
			table.insert(list, viewPart.Parent)
		end
	end

	return list
end

-- =====================
-- MAIN SEQUENCE
-- =====================
task.spawn(function()
	local function hardCleanup()
		pcall(function() RunService:UnbindFromRenderStep(LOCK_NAME) end)
		unlockControls()
		disableMovementLock()
		unlockCameraToPlayer()
		restoreOtherUiContents()

		pcall(function()
			if blur and blur.Parent then
				blur.Size = 0
				blur:Destroy()
			end
		end)

		pcall(function() loadingGui:Destroy() end)
		pcall(function() progressValue:Destroy() end)
	end

	local ok, err = xpcall(function()
		-- Lock everything immediately: no movement + no clicks
		lockControls()
		enableMovementLock()

		-- Blur immediately
		blurTo(BLUR_SIZE, BLUR_IN_TIME)

		-- Phase 1: real readiness gate
		tweenProgress(PHASE_GAME_LOADED_TO, 0.3)
		while not game:IsLoaded() do
			RunService.Heartbeat:Wait()
		end

		-- Phase 2: wait for view part, preload it, lock camera
		local viewPart = waitForNamedChild(Workspace, VIEW_PART_NAME, VIEW_PART_TIMEOUT)
		if not viewPart then
			warn(("⚠️ %s not found in Workspace within %ds. Camera will not lock."):format(VIEW_PART_NAME, VIEW_PART_TIMEOUT))
		else
			pcall(function()
				ContentProvider:PreloadAsync({ viewPart })
			end)
			lockCameraTo(viewPart)
		end

		tweenProgress(PHASE_VIEWPART_READY_TO, 0.25)

		-- Fade in UI after camera lock
		fadeToStudio(FADE_IN_TIME)
		task.wait(FADE_IN_TIME)

		-- Phase 3: real preloading (future-proof list)
		local preloadList = buildPreloadList(viewPart)
		local total = #preloadList

		if total == 0 then
			tweenProgress(PHASE_PRELOAD_TO, 0.2)
		else
			for i, asset in ipairs(preloadList) do
				pcall(function()
					ContentProvider:PreloadAsync({ asset })
				end)
				local alpha = i / total
				local target = PHASE_VIEWPART_READY_TO + (PHASE_PRELOAD_TO - PHASE_VIEWPART_READY_TO) * alpha
				progressValue.Value = math.max(progressValue.Value, target)
				RunService.Heartbeat:Wait()
			end
		end

		-- Finish to 100%
		tweenProgress(PHASE_FINISH_TO, 0.35, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
		task.wait(0.45)

		-- Extra hold (+3 seconds)
		task.wait(EXTRA_HOLD_SECONDS)

		-- Fade out + blur out
		fadeToInvisible(FADE_OUT_TIME)
		blurTo(0, BLUR_OUT_TIME)
		task.wait(FADE_OUT_TIME)

		-- Restore camera + allow movement ONLY after fully done
		pcall(function() RunService:UnbindFromRenderStep(LOCK_NAME) end)
		unlockControls()
		disableMovementLock()
		unlockCameraToPlayer()

		-- Restore all other UI exactly how it was before loading
		restoreOtherUiContents()

		-- Final cleanup
		loadingGui.Enabled = false
		loadingGui:Destroy()
		progressValue:Destroy()

		if blur and blur.Parent then
			blur:Destroy()
		end
	end, debug.traceback)

	if not ok then
		warn("❌ Loading screen crashed:\n" .. tostring(err))
		hardCleanup()
	end
end)


