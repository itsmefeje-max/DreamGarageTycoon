-- Purpose: Functional Loading Screen + Swoop + Blink + Colored Text (Fixed Pacing)
-- Runs on: Client (ReplicatedFirst)
-- Location: ReplicatedFirst
-- Dependencies: StarterGui (LoadingScreenGui), ReplicatedStorage (PreloadAssets)
-- Networking: None (Client-side logic only)
-- Security: Handles nil instances, safeguards loops, localizes variables.
-- Performance: Disconnects events, destroys UI on finish, optimized tweens.

local ReplicatedFirst = game:GetService("ReplicatedFirst")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local StarterGui = game:GetService("StarterGui")
local TweenService = game:GetService("TweenService")
local ContentProvider = game:GetService("ContentProvider")
local ContextActionService = game:GetService("ContextActionService")
local Lighting = game:GetService("Lighting")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

ReplicatedFirst:RemoveDefaultLoadingScreen()

-- =====================
-- CONFIG
-- =====================
local VIEW_PART_NAME = "LoadingViewPart"
local VIEW_PART_TIMEOUT = 10 -- Reduced slightly for responsiveness
local PRELOAD_FOLDER_NAME = "PreloadAssets"

local LOADING_TEXT_START = " Loading " -- Text to show before numbers appear

-- [[ Colored Text Config ]]
local DONE_OPTIONS = {
	{ Text = "Done",      Color = Color3.fromRGB(85, 255, 127) },  -- Bright Green
	{ Text = "Ready!",    Color = Color3.fromRGB(0, 255, 255) },   -- Cyan
	{ Text = "Let's Go",  Color = Color3.fromRGB(255, 170, 0) },   -- Gold/Orange
	{ Text = "Finally",   Color = Color3.fromRGB(255, 105, 180) }, -- Hot Pink
	{ Text = "Loaded",    Color = Color3.fromRGB(170, 255, 0) },   -- Lime
	{ Text = "Success",   Color = Color3.fromRGB(100, 149, 237) }  -- Cornflower Blue
}

-- [[ ANIMATION CONFIG ]]
local ANIMATION_DURATION = 5.5 
local BLUR_SIZE = 20
local BLUR_IN_TIME = 0.6 
local BLUR_OUT_TIME = 3.0 

local SWOOP_DURATION = 1.8 
local FADE_OUT_TIME = 0.4 
local FADE_IN_TIME = 0.8  

local EXTRA_HOLD_SECONDS = 2.0 
local FAILSAFE_TOTAL_SECONDS = 35

local LOCK_NAME = "LoadingScreenCameraLock"
local FREEZE_ACTION = "LoadingScreenFreeze"

-- Progress ranges
local PHASE_GAME_LOADED_TO = 0.20 -- Boosted slightly
local PHASE_VIEWPART_READY_TO = 0.40
local PHASE_PRELOAD_TO = 0.90
local PHASE_FINISH_TO = 1.00

-- =====================
-- BASICS
-- =====================
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local camera = Workspace.CurrentCamera or Workspace:WaitForChild("Camera")
playerGui:SetAttribute("LoadingScreenActive", true)

-- =====================
-- LOAD UI SETUP
-- =====================
local sourceGui = StarterGui:WaitForChild("LoadingScreenGui", 10)
if not sourceGui then warn("‚ùå LoadingScreenGui missing!") return end

local loadingGui = sourceGui:Clone()
loadingGui.Name = "ActiveLoadingScreen"
loadingGui.ResetOnSpawn = false
loadingGui.Enabled = true
loadingGui.IgnoreGuiInset = true 
loadingGui.DisplayOrder = 999 
loadingGui.Parent = playerGui

-- [[ Transition Frame for Blink ]]
local transitionFrame = Instance.new("Frame")
transitionFrame.Name = "TransitionFrame"
transitionFrame.Size = UDim2.fromScale(1, 1)
transitionFrame.BackgroundColor3 = Color3.new(0, 0, 0) -- Pure Black
transitionFrame.BackgroundTransparency = 1 -- Start invisible
transitionFrame.ZIndex = 2000 -- Ensure it's on top of everything
transitionFrame.Parent = loadingGui

-- =====================
-- UTIL
-- =====================
local function safeTween(instance, info, goals)
	local t = TweenService:Create(instance, info, goals)
	t:Play()
	return t
end

local function waitForNamedChild(parent, childName, timeout)
	local start = os.clock()
	while os.clock() - start < timeout do
		local child = parent:FindFirstChild(childName)
		if child then return child end
		RunService.Heartbeat:Wait()
	end
	return nil
end

-- =====================
-- BLUR
-- =====================
local blur = Lighting:FindFirstChild("LoadingScreenBlur")
if not blur then
	blur = Instance.new("BlurEffect")
	blur.Name = "LoadingScreenBlur"
	blur.Size = 0
	blur.Parent = Lighting
end

local function blurTo(size, duration)
	return safeTween(blur, TweenInfo.new(duration, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), { Size = size })
end

-- =====================
-- INPUT LOCKS
-- =====================
local function lockControls()
	ContextActionService:BindAction(
		FREEZE_ACTION,
		function() return Enum.ContextActionResult.Sink end,
		false,
		unpack(Enum.PlayerActions:GetEnumItems())
	)
end

local function unlockControls()
	pcall(function() ContextActionService:UnbindAction(FREEZE_ACTION) end)
end

local movementLock = { active = false, conn = nil, original = {} }

local function applyMovementLock(char)
	if not movementLock.active or not char then return end
	local hum = char:FindFirstChildOfClass("Humanoid") or char:WaitForChild("Humanoid", 5)
	if not hum then return end

	if not movementLock.original[hum] then
		movementLock.original[hum] = {
			WalkSpeed = hum.WalkSpeed,
			JumpPower = hum.JumpPower,
			JumpHeight = hum.JumpHeight,
			AutoRotate = hum.AutoRotate,
		}
	end
	hum.WalkSpeed = 0
	hum.JumpPower = 0
	hum.JumpHeight = 0
	hum.AutoRotate = false
	pcall(function() hum:Move(Vector3.zero, true) end)
end

local function enableMovementLock()
	movementLock.active = true
	if player.Character then applyMovementLock(player.Character) end
	movementLock.conn = player.CharacterAdded:Connect(applyMovementLock)
end

local function disableMovementLock()
	movementLock.active = false
	if movementLock.conn then movementLock.conn:Disconnect() movementLock.conn = nil end
	for hum, original in pairs(movementLock.original) do
		if hum and hum.Parent then
			hum.WalkSpeed = original.WalkSpeed or 16
			hum.JumpPower = original.JumpPower or 50
			hum.JumpHeight = original.JumpHeight or 7.2
			hum.AutoRotate = (original.AutoRotate ~= nil) and original.AutoRotate or true
		end
	end
	table.clear(movementLock.original)
end

local function lockCameraTo(part)
	if not (part and part:IsA("BasePart")) then return end
	camera.CameraType = Enum.CameraType.Scriptable
	camera.CFrame = part.CFrame
	RunService:BindToRenderStep(LOCK_NAME, Enum.RenderPriority.Camera.Value + 1, function()
		if part and part.Parent then camera.CFrame = part.CFrame end
		if camera.CameraType ~= Enum.CameraType.Scriptable then camera.CameraType = Enum.CameraType.Scriptable end
	end)
end

-- [[ SWOOP + BLINK TRANSITION ]]
local function unlockCameraToPlayer()
	pcall(function() RunService:UnbindFromRenderStep(LOCK_NAME) end)

	local char = player.Character or player.CharacterAdded:Wait()
	local hum = char:FindFirstChildOfClass("Humanoid") or char:WaitForChild("Humanoid", 10)
	local root = char:FindFirstChild("HumanoidRootPart") or char:WaitForChild("HumanoidRootPart", 10)

	if root and hum then
		camera.CameraType = Enum.CameraType.Scriptable

		-- 1. Swoop Calculation
		local offset = CFrame.new(0, 5, 12) 
		local targetCFrame = root.CFrame:ToWorldSpace(offset)
		targetCFrame = CFrame.lookAt(targetCFrame.Position, root.Position + Vector3.new(0, 2, 0))

		-- 2. Play Swoop
		local swoopInfo = TweenInfo.new(SWOOP_DURATION, Enum.EasingStyle.Quart, Enum.EasingDirection.Out)
		local tween = TweenService:Create(camera, swoopInfo, { CFrame = targetCFrame })
		tween:Play()
		tween.Completed:Wait() -- Wait for camera to arrive behind player

		-- 3. Blink: Fade Out (Black)
		local fadeOut = TweenService:Create(transitionFrame, TweenInfo.new(FADE_OUT_TIME, Enum.EasingStyle.Sine), { BackgroundTransparency = 0 })
		fadeOut:Play()
		fadeOut.Completed:Wait() -- Wait for total darkness

		-- 4. Switch Camera safely
		camera.CameraSubject = hum
		camera.CameraType = Enum.CameraType.Custom

		-- 5. Blink: Fade In (Clear)
		local fadeIn = TweenService:Create(transitionFrame, TweenInfo.new(FADE_IN_TIME, Enum.EasingStyle.Sine), { BackgroundTransparency = 1 })
		fadeIn:Play()
	else
		camera.CameraType = Enum.CameraType.Custom
	end
end

-- =====================
-- UI LOGIC
-- =====================
local clickShield = Instance.new("Frame")
clickShield.Name = "ClickShield"
clickShield.Size = UDim2.new(1, 0, 1, 0)
clickShield.BackgroundTransparency = 1
clickShield.Active = true 
clickShield.ZIndex = -1
clickShield.Parent = loadingGui

local bgFrame = loadingGui:WaitForChild("Frame", 5)
if not bgFrame then loadingGui:Destroy() return end
bgFrame.Visible = false 

local barContainer = bgFrame:FindFirstChild("ProgressBarContainer")
local barFill = barContainer and barContainer:FindFirstChild("ProgressBar")
local progressText = barContainer and barContainer:FindFirstChild("ProgressText")
local progressValue = Instance.new("NumberValue")
progressValue.Value = 0

local MAX_X_SCALE, MAX_X_OFFSET, Y_SCALE, Y_OFFSET

local function updateProgressBar(v)
	if not barFill then return end
	local clamped = math.clamp(v, 0, 1)
	barFill.Size = UDim2.new(MAX_X_SCALE * clamped, MAX_X_OFFSET * clamped, Y_SCALE, Y_OFFSET)

	if progressText and progressText:IsA("TextLabel") then
		if clamped <= 0.05 then
			-- [[ FIX: Force "Loading" text at start ]]
			progressText.Text = LOADING_TEXT_START
		elseif clamped >= 0.99 then
			if not progressText:GetAttribute("DoneMsgSet") then
				-- [[ Random Colored Text ]]
				local choice = DONE_OPTIONS[math.random(1, #DONE_OPTIONS)]
				progressText.Text = choice.Text
				progressText.TextColor3 = choice.Color
				progressText:SetAttribute("DoneMsgSet", true)
			end
		else
			progressText.Text = string.format("%d%%", math.floor(clamped * 100 + 0.5))
		end
	end
end

if barFill then
	MAX_X_SCALE = barFill.Size.X.Scale
	MAX_X_OFFSET = barFill.Size.X.Offset
	Y_SCALE = barFill.Size.Y.Scale
	Y_OFFSET = barFill.Size.Y.Offset
	
	-- [[ FIX: Initialize immediately before any tweening ]]
	barFill.Size = UDim2.new(0, 0, Y_SCALE, Y_OFFSET)
	updateProgressBar(0) 

	progressValue.Changed:Connect(updateProgressBar)
end

local function tweenProgress(toValue, duration)
	-- [[ FIX: Ensure we clamp inputs to avoid overshooting ]]
	local goal = math.clamp(toValue, 0, 1)
	local t = safeTween(progressValue, TweenInfo.new(duration, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), { Value = goal })
	return t
end

-- =====================
-- RECURSIVE HIDER
-- =====================
local hiddenFrames = {}
local visualScannerConn = nil

local function scanAndHide(parent)
	if not parent then return end
	for _, child in ipairs(parent:GetChildren()) do
		if child == loadingGui then continue end
		if child:IsA("GuiObject") then
			if child.Visible then
				hiddenFrames[child] = true
				child.Visible = false
				continue 
			end
		end
		if child:IsA("Folder") or child:IsA("ScreenGui") or child:IsA("GuiObject") then
			scanAndHide(child)
		end
	end
end

local function startHidingVisuals()
	scanAndHide(playerGui)
	visualScannerConn = task.spawn(function()
		while playerGui:GetAttribute("LoadingScreenActive") do
			scanAndHide(playerGui)
			task.wait(0.2)
		end
	end)
end

local function restoreVisuals()
	if visualScannerConn then task.cancel(visualScannerConn) visualScannerConn = nil end
	for item, _ in pairs(hiddenFrames) do
		if item and item.Parent then
			item.Visible = true
		end
	end
	table.clear(hiddenFrames)
end

-- =====================
-- LOADING SCREEN FADE
-- =====================
local studioProps = {}
local function recordProps(inst)
	local props, changed = {}, false
	if inst:IsA("GuiObject") and inst.BackgroundTransparency < 1 then props.BackgroundTransparency = inst.BackgroundTransparency changed = true end
	if (inst:IsA("TextLabel") or inst:IsA("TextButton") or inst:IsA("TextBox")) and inst.TextTransparency < 1 then props.TextTransparency = inst.TextTransparency changed = true end
	if (inst:IsA("ImageLabel") or inst:IsA("ImageButton")) and inst.ImageTransparency < 1 then props.ImageTransparency = inst.ImageTransparency changed = true end
	if inst:IsA("UIStroke") and inst.Transparency < 1 then props.Transparency = inst.Transparency changed = true end
	if changed then studioProps[inst] = props end
end

local function setInvisible(inst)
	local props = studioProps[inst]
	if not props then return end
	if inst:IsA("GuiObject") and props.BackgroundTransparency ~= nil then inst.BackgroundTransparency = 1 end
	if (inst:IsA("TextLabel") or inst:IsA("TextButton") or inst:IsA("TextBox")) and props.TextTransparency ~= nil then inst.TextTransparency = 1 end
	if (inst:IsA("ImageLabel") or inst:IsA("ImageButton")) and props.ImageTransparency ~= nil then inst.ImageTransparency = 1 end
	if inst:IsA("UIStroke") and props.Transparency ~= nil then inst.Transparency = 1 end
end

local function fadeToRecorded(duration)
	local info = TweenInfo.new(duration, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
	for inst, goals in pairs(studioProps) do if inst and inst.Parent then safeTween(inst, info, goals) end end
end

local function fadeToInvisible(duration)
	local info = TweenInfo.new(duration, Enum.EasingStyle.Sine, Enum.EasingDirection.In)
	for inst, props in pairs(studioProps) do
		if inst and inst.Parent then
			local goals = {}
			if inst:IsA("GuiObject") and props.BackgroundTransparency ~= nil then goals.BackgroundTransparency = 1 end
			if (inst:IsA("TextLabel") or inst:IsA("TextButton") or inst:IsA("TextBox")) and props.TextTransparency ~= nil then goals.TextTransparency = 1 end
			if (inst:IsA("ImageLabel") or inst:IsA("ImageButton")) and props.ImageTransparency ~= nil then goals.ImageTransparency = 1 end
			if inst:IsA("UIStroke") and props.Transparency ~= nil then goals.Transparency = 1 end
			if next(goals) then safeTween(inst, info, goals) end
		end
	end
end

for _, inst in ipairs(loadingGui:GetDescendants()) do recordProps(inst) end
for inst, _ in pairs(studioProps) do setInvisible(inst) end

-- =====================
-- EXECUTION
-- =====================
local finished = false
local function cleanup()
	if finished then return end
	finished = true

	-- 1. Swoop Camera + Blink (This yields for Swoop + FadeOut)
	unlockCameraToPlayer()

	-- 2. Unlock Controls & Visuals
	unlockControls()
	disableMovementLock()
	pcall(function() playerGui:SetAttribute("LoadingScreenActive", false) end)
	restoreVisuals() 

	pcall(function() if blur and blur.Parent then blur.Size = 0 blur:Destroy() end end)
	pcall(function() loadingGui:Destroy() end)
	pcall(function() progressValue:Destroy() end)
end

-- Failsafe timeout
task.spawn(function()
	local start = os.clock()
	while not finished and (os.clock() - start) < FAILSAFE_TOTAL_SECONDS do task.wait(1) end
	if not finished then cleanup() end
end)

-- Main Sequence
task.spawn(function()
	local ok, err = xpcall(function()
		lockControls()
		enableMovementLock()
		startHidingVisuals()
		blurTo(BLUR_SIZE, BLUR_IN_TIME)

		bgFrame.Visible = true
		local finalPos = bgFrame.Position
		local startPos = UDim2.new(finalPos.X.Scale, finalPos.X.Offset, finalPos.Y.Scale + 1.5, finalPos.Y.Offset)
		bgFrame.Position = startPos

		safeTween(bgFrame, TweenInfo.new(ANIMATION_DURATION, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), { Position = finalPos })
		fadeToRecorded(ANIMATION_DURATION)

		-- Give the UI a moment to appear
		task.wait(ANIMATION_DURATION * 0.3)

		-- [[ PHASE 1: GAME LOAD ]]
		-- We allow this tween to run, but we check Game Loaded
		local t1 = tweenProgress(PHASE_GAME_LOADED_TO, 1.5)
		if not game:IsLoaded() then 
			game.Loaded:Wait() 
		else
			-- If already loaded, wait briefly to show visual progress (Fixes instant jump)
			t1.Completed:Wait() 
		end

		-- [[ PHASE 2: VIEW PART ]]
		local viewPart = waitForNamedChild(Workspace, VIEW_PART_NAME, VIEW_PART_TIMEOUT)
		if viewPart then
			pcall(function() ContentProvider:PreloadAsync({ viewPart }) end)
			lockCameraTo(viewPart)
		end
		
		-- Smoothly tween to Phase 2 (Wait for it to finish visually)
		tweenProgress(PHASE_VIEWPART_READY_TO, 1.2).Completed:Wait()

		-- [[ PHASE 3: ASSETS PRELOAD ]]
		local folder = ReplicatedStorage:FindFirstChild(PRELOAD_FOLDER_NAME)
		local preloadList = { loadingGui } -- Ensure list isn't empty
		if folder then for _, inst in ipairs(folder:GetDescendants()) do table.insert(preloadList, inst) end end
		if viewPart then table.insert(preloadList, viewPart) end

		if #preloadList == 0 then
			tweenProgress(PHASE_PRELOAD_TO, 1.0).Completed:Wait()
		else
			-- Calculate step size. If list is small, we add a minimum wait
			local startVal = progressValue.Value
			local dist = PHASE_PRELOAD_TO - startVal
			
			for i, asset in ipairs(preloadList) do
				pcall(function() ContentProvider:PreloadAsync({ asset }) end)
				
				local alpha = i / #preloadList
				local target = startVal + (dist * alpha)
				
				-- Tween slightly to the new target
				tweenProgress(target, 0.1) 
				
				-- [[ FIX: Force a small wait so the bar doesn't zip instantly ]]
				if #preloadList < 20 then
					task.wait(0.05) 
				else
					RunService.Heartbeat:Wait()
				end
			end
		end

		-- [[ PHASE 4: FINISH ]]
		-- Tween to 100% and WAIT for it to visually get there
		tweenProgress(PHASE_FINISH_TO, 1.0).Completed:Wait()
		
		task.wait(0.25)
		task.wait(EXTRA_HOLD_SECONDS)

		local exitPos = UDim2.new(finalPos.X.Scale, finalPos.X.Offset, finalPos.Y.Scale - 1.5, finalPos.Y.Offset)
		safeTween(bgFrame, TweenInfo.new(ANIMATION_DURATION, Enum.EasingStyle.Quart, Enum.EasingDirection.In), { Position = exitPos })
		fadeToInvisible(ANIMATION_DURATION)

		-- [[ FADE BLUR OUT BEFORE SWOOP STARTS ]]
		blurTo(0, BLUR_OUT_TIME) 

		-- Wait for UI to be gone
		task.wait(ANIMATION_DURATION)

		-- Run cleanup (Contains the Camera Swoop + Blink)
		cleanup()
	end, debug.traceback)

	if not ok then warn(err) cleanup() end
end)
