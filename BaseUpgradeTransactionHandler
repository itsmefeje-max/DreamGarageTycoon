-- Purpose: Verification for Buying AND Equipping/Unequipping Skins safely.
-- Runs on: Server
-- Location: ServerScriptService
-- Dependencies: ReplicatedStorage, MarketplaceService, HttpService, Players, BaseSkinStats
-- Public API: ShopRemotes.BaseUpgradeTransaction
-- Networking: Client invokes BaseUpgradeTransaction (RemoteFunction) -> Server processes -> Returns boolean, string
-- Security: Transaction locks prevent spam-buying and wallet draining. Server-authoritative price checking.
-- Performance: Lightweight table hashing for locks. pcall wrapper prevents hanging locks.
-- Notes: Assumes BaseSkinStats module exists and is structured correctly.

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local MarketplaceService = game:GetService("MarketplaceService")
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")

local Remotes = ReplicatedStorage:WaitForChild("ShopRemotes")
local TransactionFunc = Remotes:WaitForChild("BaseUpgradeTransaction")
local StatsModule = require(ReplicatedStorage:WaitForChild("BaseSkinStats"))

-- üõ°Ô∏è SECURITY: Transaction Locks
local activeTransactions = {}

-- üí∞ UNIFIED TRANSACTION & EQUIP FUNCTION
TransactionFunc.OnServerInvoke = function(player, skinName, actionType)
	-- Prevent remote spam & race conditions
	if activeTransactions[player.UserId] then
		return false, "Transaction in progress. Please wait."
	end
	activeTransactions[player.UserId] = true

	-- Use a wrapper to ensure the lock is ALWAYS released, even if the script errors
	local success, result, msg = pcall(function()
		local skinData = StatsModule[skinName]

		-- 1. READ OWNERSHIP
		local ownedRaw = player:GetAttribute("OwnedBaseSkins") or "[]"
		local ownedTable = {}
		pcall(function() ownedTable = HttpService:JSONDecode(ownedRaw) end)
		local ownsSkin = table.find(ownedTable, skinName) ~= nil

		-- ========================================================================
		-- üõ†Ô∏è EQUIP / UNEQUIP LOGIC
		-- ========================================================================
		if actionType == "Equip" then
			if ownsSkin then
				player:SetAttribute("EquippedSkin", skinName)
				print("‚úÖ " .. player.Name .. " equipped " .. skinName)
				return true, "Equipped"
			else
				return false, "You do not own this!"
			end

		elseif actionType == "Unequip" then
			player:SetAttribute("EquippedSkin", "Default")
			print("üö´ " .. player.Name .. " unequipped " .. skinName)
			return true, "Unequipped"

			-- ========================================================================
			-- üí∞ BUYING LOGIC
			-- ========================================================================
		elseif actionType == "Cash" then
			if not skinData then return false, "Invalid Skin" end
			if ownsSkin then return false, "Already Owned" end

			local leaderstats = player:FindFirstChild("leaderstats")
			local wallet = leaderstats and leaderstats:FindFirstChild("Wallet") 

			if wallet and wallet.Value >= skinData.PriceCash then
				-- A. Deduct Money
				wallet.Value = wallet.Value - skinData.PriceCash

				-- B. Grant Ownership
				table.insert(ownedTable, skinName)

				-- C. Update Attributes (Client sees this instantly)
				player:SetAttribute("OwnedBaseSkins", HttpService:JSONEncode(ownedTable))
				player:SetAttribute("EquippedSkin", skinName) -- Auto-Equip on buy

				print("‚úÖ " .. player.Name .. " bought " .. skinName .. " with Wallet Cash")
				return true, "Success"
			else
				return false, "Insufficient Wallet Cash"
			end

		elseif actionType == "Robux" then
			if not skinData then return false, "Invalid Skin" end
			if ownsSkin then return false, "Already Owned" end

			if skinData.ProductId > 0 then
				MarketplaceService:PromptProductPurchase(player, skinData.ProductId)
				return true, "Prompted"
			else
				return false, "No Product ID Configured"
			end
		end

		return false, "Invalid Action"
	end)

	-- Release Lock
	activeTransactions[player.UserId] = nil

	if not success then
		warn("‚ö†Ô∏è Transaction Error for " .. player.Name .. ": " .. tostring(result))
		return false, "System Error"
	end

	return result, msg
end

-- Cleanup locks if a player leaves mid-transaction
Players.PlayerRemoving:Connect(function(player)
	activeTransactions[player.UserId] = nil
end)
